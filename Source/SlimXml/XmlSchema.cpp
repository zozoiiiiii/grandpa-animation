#include "XmlSchema.h"
#include <cassert>
#include <fstream>

namespace slim
{

const Char* ATTR_MULTIPLE = SXT("multiple");
const Char* ATTR_RECURSIVE = SXT("recursive");
const Char* ATTR_ATTRIBUTE = SXT("attribute");
const Char* ATTR_TYPE = SXT("type");
const Char* ATTR_DEFAULT = SXT("default");

#ifdef SLIM_USE_WCHAR
	#define LEFT_QUOTE L"L\""
#else
	#define LEFT_QUOTE "\""
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////
bool XmlSchema::constructFromXml(XmlDocument* file)
{
	clearChild();

	XmlNode* comment = addChild(SXT("xml data schema"), COMMENT);
	return parseNodeStruct(this, file);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
bool XmlSchema::generateCode(const Char* filename, const Char* pchFilename) const
{
	String headerCode, sourceCode;

	if (!generateCodeForNode(this, headerCode, sourceCode))
	{
		return false;
	}

	String note =
SXT("///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\
//this file is automatically generated, do not modify.\r\n\
///////////////////////////////////////////////////////////////////////////////////////////////////\r\n");

	String definition = filename;
	int pos1 = definition.find_last_of(SXT('/'));
	int pos2 = definition.find_last_of(SXT('\\'));
	int slashPos = std::max(pos1 == String::npos ? -1: pos1,
								pos2 == String::npos ? -1: pos2);
	definition = definition.substr(slashPos + 1, definition.size() - slashPos - 1);
	String headerInclude;
	headerInclude += SXT("#ifndef __XML_");
	headerInclude += definition;
	headerInclude += SXT("_H__\r\n#define __XML_");
	headerInclude += definition;
	headerInclude += SXT("_H__\r\n\r\n#include \"SlimXml.h\"\r\n#include <vector>\r\n\r\n");
	String nameSpace;
	nameSpace = SXT("namespace ");
	nameSpace += definition;
	nameSpace += SXT("\r\n{\r\n");

	headerCode = note + headerInclude + nameSpace + headerCode;
	headerCode += SXT("}\r\n\r\n");
	headerCode += SXT("#endif\r\n");

	String sourceInclude;
	if (pchFilename != NULL)
	{
		sourceInclude += SXT("#include \"");
		sourceInclude += pchFilename;
		sourceInclude += SXT("\"\r\n");
	}
	sourceInclude += SXT("#include \"");
	sourceInclude += definition;
	sourceInclude += SXT(".h\"\r\n#include <cassert>\r\n\r\nusing namespace slim;\r\n\r\n");

	sourceCode = note + sourceInclude + nameSpace + sourceCode;
	sourceCode += SXT("}\r\n");

	assert(filename != NULL);

	String filenameString = filename;
	filenameString += SXT(".h");

	//header
	std::fstream file;
	file.open(filenameString.c_str(), std::ios_base::out | std::ios_base::binary);
	if (!file.is_open())
	{
		return false;
	}

#ifdef SLIM_USE_WCHAR
	//always write in utf-8
	unsigned char bom[3];
	bom[0] = 0xef;
	bom[1] = 0xbb;
	bom[2] = 0xbf;
	size_t bufferSize = headerCode.size() * 4;
	char* buffer = new char[bufferSize];
	size_t characterCount = utf16toutf8(headerCode.c_str(), headerCode.size(), buffer, bufferSize);
	file.write((char*)bom, 3);
	file.write(buffer, characterCount);
	delete[] buffer;
#else
	file.write(headerCode.c_str(), headerCode.size());
#endif

	file.close();

	//cpp
	filenameString = filename;
	filenameString += SXT(".cpp");
	file.open(filenameString.c_str(), std::ios_base::out | std::ios_base::binary);
	if (!file.is_open())
	{
		return false;
	}

#ifdef SLIM_USE_WCHAR
	bufferSize = sourceCode.size() * 3;
	buffer = new char[bufferSize];
	characterCount = utf16toutf8(sourceCode.c_str(), sourceCode.size(), buffer, bufferSize);
	file.write((char*)bom, 3);
	file.write(buffer, characterCount);
	delete[] buffer;
#else
	file.write(sourceCode.c_str(), sourceCode.size());
#endif

	file.close();
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//parse data schema from node
//src		data node
//dst		schema node
bool XmlSchema::parseNodeStruct(XmlNode* dst, XmlNode* src)
{
	assert(dst != NULL);
	assert(src != NULL);

	NodeIterator nodeIterator;
	AttributeIterator attriIterator;

	for (XmlAttribute* attribute = src->getFirstAttribute(attriIterator);
		attribute != NULL;
		attribute = src->getNextAttribute(attriIterator))
	{
		XmlNode* structure = dst->findChild(attribute->getName());
		if (structure == NULL)
		{
			//first time show up
			structure = dst->addChild(attribute->getName());
			structure->addAttribute(ATTR_TYPE, guessType(attribute->getValue<const Char*>()));
			structure->addAttribute(ATTR_ATTRIBUTE, SXT("true"));
		}
	}

	for (XmlNode* child = src->getFirstChild(nodeIterator);
		  child != NULL;
		  child = src->getNextChild(nodeIterator))
	{
		if (child->getType() != ELEMENT)
		{
			continue;
		}
		XmlNode* structure = dst->findChild(child->getName());
		if (structure == NULL)
		{
			//first time show up
			bool recursive = false;
			const XmlNode* parent = dst;
			while (parent != NULL)
			{
				if (Strcmp(parent->getName(), child->getName()) == 0)
				{
					recursive = true;
					break;
				}
				parent = parent->getParent();
			}
			structure = dst->addChild(child->getName());
			if (recursive)
			{
				structure->addAttribute(ATTR_RECURSIVE, SXT("true"));
			}
			else if (!child->hasChild() && !child->hasAttribute())
			{
				//simple type, must have a type attribute
				structure->addAttribute(ATTR_TYPE, guessType(child->getValue<const Char*>()));
			}
		}
		else if (structure->findAttribute(ATTR_ATTRIBUTE) != NULL)
		{
			//child and attribute can't have same name
			return false;
		}

		XmlAttribute* multiple = structure->findAttribute(ATTR_MULTIPLE);
		if (multiple == NULL || !multiple->getValue<bool>())
		{
			NodeIterator iter;
			if (src->findFirstChild(child->getName(), iter) != NULL
				&& src->findNextChild(child->getName(), iter) != NULL)
			{
				if (multiple == NULL)
				{
					multiple = structure->addAttribute(ATTR_MULTIPLE, SXT(""));
				}
				multiple->setValue(true);
			}
		}

		if (!structure->findAttribute(ATTR_RECURSIVE) && (child->hasChild() || child->hasAttribute()))
		{
			parseNodeStruct(structure, child);
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
const Char* XmlSchema::guessType(const Char* content) const
{
	assert(content != NULL);

	if (Strcmp(content, SXT("true")) == 0
		|| Strcmp(content, SXT("false")) == 0)
	{
		return SXT("bool");
	}

	bool foundDot = false;
	bool foundSign = false;
	bool foundLeftBrack = false;
	if (*content == 0)
	{
		return SXT("string");
	}
	Char first = *content;
	int numberCount = 1;
	if (first == SXT('('))
	{		
		content++;
		foundLeftBrack = true;
	}
	for (; *content != 0; ++content)
	{
		if ((*content >= SXT('0') && *content <= SXT('9')))
		{
			continue;
		}
		if (*content == SXT('.'))
		{
			if (foundDot) 
			{
				return SXT("string");
			}
			foundDot = true;
		} 
		else if (*content == SXT('-'))
		{
			if (foundSign)
			{
				return SXT("string");
			}
			foundSign = true;
		}
		else if (*content == SXT(','))
		{
			numberCount++;
			foundSign = false;
			foundDot = false;			
		}
		else if (*content == SXT(')'))
		{
			if (foundLeftBrack)
			{
				break;
			}
			return SXT("string");
		}
		else
		{
			return SXT("string");
		}
	}
	
	switch(numberCount)
	{
	case 1 : 
		if (!foundDot)
		{
			return SXT("int");
		}
		return SXT("float");
	}
	return SXT("string");
}

///////////////////////////////////////////////////////////////////////////////////////////////////
bool XmlSchema::generateCodeForNode(const XmlNode* node, String& headerCode, String& sourceCode) const
{
	assert(node != NULL);

	if (node->getType() == ELEMENT)
	{
		String structDefinition;
		structDefinition += SXT("///////////////////////////////////////////////////////////////////////////////////////////////////\r\n");
		structDefinition += SXT("struct ");
		structDefinition += node->getName();
		structDefinition += SXT("\r\n{\r\n");
		//constructor
		int index = 0;
		NodeIterator iter;
		for (XmlNode* child = node->getFirstChild(iter);
			  child != NULL;
			  child = node->getNextChild(iter))
		{
			if (child->isEmpty() && child->getType() == ELEMENT)
			{
				//simple type
				addConstructorItem(child, structDefinition, index);
			}
		}
		if (index > 0)
		{
			structDefinition += SXT("	{\r\n	}\r\n");
		}
		//destructor
		for (XmlNode* child = node->getFirstChild(iter);
			child != NULL;
			child = node->getNextChild(iter))
		{
			if (child->findAttribute(ATTR_RECURSIVE) != NULL
				&& child->findAttribute(ATTR_MULTIPLE) == NULL)
			{
				//recursive pointer, need to delete
				structDefinition += SXT("	~");
				structDefinition += node->getName();
				structDefinition += SXT("()\r\n	{\r\n		if (Child != NULL)\r\n		{\r\n			delete Child;\r\n");
				structDefinition += SXT("			Child = NULL;\r\n		}\r\n	}\r\n");
				break;	//can't have more than one
			}
		}

		structDefinition += SXT("	void read(const slim::XmlNode* node);\r\n	void write(slim::XmlNode* node) const;\r\n\r\n");

		String readingCode;
		readingCode += SXT("///////////////////////////////////////////////////////////////////////////////////////////////////\r\n");
		readingCode += SXT("void ");
		readingCode += node->getName();
		readingCode += SXT("::read(const XmlNode* node)\r\n{\r\n	assert(node != NULL);\r\n");
		readingCode += SXT("\r\n	NodeIterator iter;\r\n	const XmlNode* childNode = NULL;\r\n	const XmlAttribute* attribute = NULL;\r\n");

		String writingCode;
		writingCode += SXT("///////////////////////////////////////////////////////////////////////////////////////////////////\r\n");
		writingCode += SXT("void ");
		writingCode += node->getName();
		writingCode += SXT("::write(XmlNode* node) const\r\n{\r\n	assert(node != NULL);\r\n\r\n	node->clearChild();\r\n	node->clearAttribute();");
		writingCode += SXT("\r\n\r\n	XmlNode* childNode = NULL;\r\n	XmlAttribute* attribute = NULL;\r\n");

		size_t typeWidth = getNodeMemberTypeWidth(node);

		for (const XmlNode* child = node->getFirstChild(iter);
			  child != NULL;
			  child = node->getNextChild(iter))
		{
			if (child->getType() != ELEMENT)
			{
				continue;
			}
			XmlAttribute* multiple = child->findAttribute(ATTR_MULTIPLE);
			bool recursive = (child->findAttribute(ATTR_RECURSIVE) != NULL);
			if (child->isEmpty() && !recursive)
			{
				//simple type
				if (multiple != NULL && multiple->getValue<bool>())
				{
					addSimpleVector(child, structDefinition, typeWidth, readingCode, writingCode);
				}
				else
				{
					addSimpleMember(child, structDefinition, typeWidth, readingCode, writingCode);
				}
			}
			else
			{
				//struct type
				if (multiple != NULL && multiple->getValue<bool>())
				{
					addStructVector(child, structDefinition, typeWidth, readingCode, writingCode);
				}
				else
				{
					addStructMember(child, structDefinition, typeWidth, readingCode, writingCode);
				}
			}
		}
		structDefinition += SXT("};\r\n\r\n");

		readingCode += SXT("}\r\n\r\n");
		writingCode += SXT("}\r\n\r\n");

		sourceCode += readingCode;
		sourceCode += writingCode;

		//add to front
		headerCode = structDefinition + headerCode;
	}

	NodeIterator iter;
	for (const XmlNode* child = node->getFirstChild(iter);
		  child != NULL;
		  child = node->getNextChild(iter))
	{
		if (child->hasChild())
		{
			if (!generateCodeForNode(child, headerCode, sourceCode))
			{
				return false;
			}
		}
	}
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
size_t XmlSchema::getNodeMemberTypeWidth(const XmlNode* node) const
{
	size_t maxWidth = 0;
	size_t width = 0;
	NodeIterator iter;
	for (const XmlNode* child = node->getFirstChild(iter);
		child != NULL;
		child = node->getNextChild(iter))
	{
		XmlAttribute* multiple = child->findAttribute(ATTR_MULTIPLE);

		if (child->isEmpty())
		{
			//simple type
			XmlAttribute* type = child->findAttribute(ATTR_TYPE);
			if (type == NULL)
			{
				continue;
			}
			width = getSimpleTypeString(type).size();
			if (multiple != NULL && multiple->getValue<bool>())
			{
				width += Strlen(SXT("std::vector<>"));
			}
		}
		else
		{
			//struct type
			width = Strlen(child->getName());
			if (multiple != NULL && multiple->getValue<bool>())
			{
				width += Strlen(SXT("std::vector<>"));
			}
		}
		if (width > maxWidth)
		{
			maxWidth = width;
		}
	}
	return maxWidth;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void XmlSchema::addSimpleMember(const XmlNode* child, String& structDefinition, size_t typeWidth,
								 String& readingFunction, String& writingFunction) const
{
	assert(child != NULL);

	XmlAttribute* type = child->findAttribute(ATTR_TYPE);
	XmlAttribute* defaultAttribute = child->findAttribute(ATTR_DEFAULT);
	bool inAttribute = (child->findAttribute(ATTR_ATTRIBUTE) != NULL);
	if (type == NULL)
	{
		return;
	}
	String typeString = getSimpleTypeString(type);
	size_t thisWidth = typeString.size();
	assert(thisWidth < typeWidth + 1);
	for (size_t i = 0; i < typeWidth + 1 - thisWidth; ++i)
	{
		typeString += SXT(" ");
	}
	
	structDefinition += SXT("	");
	structDefinition += typeString;
	structDefinition += child->getName();
	structDefinition += SXT(";\r\n");	

	readingFunction += inAttribute ? SXT("\r\n	attribute = node->findAttribute(")
									: SXT("\r\n	childNode = node->findChild(");
	readingFunction += LEFT_QUOTE;
	readingFunction += child->getName();
	readingFunction += inAttribute ? SXT("\");\r\n	if (attribute != NULL)\r\n	{\r\n		")
									: SXT("\");\r\n	if (childNode != NULL)\r\n	{\r\n		");
	readingFunction += child->getName();
	readingFunction += inAttribute ? SXT(" = attribute->get")
									: SXT(" = childNode->get");
	String typeName = type->getValue<const Char*>();
	typeName[0] -= 32;
	readingFunction += typeName;
	readingFunction += SXT("();\r\n	}\r\n");

	writingFunction += SXT("\r\n	if (");
	writingFunction += child->getName();
	writingFunction += SXT(" != ");

	if (defaultAttribute != NULL)
	{
		//with initialized value
		if (Strcmp(type->getValue<const Char*>(), SXT("string")) == 0)
		{
			writingFunction += LEFT_QUOTE;
		}
		writingFunction += defaultAttribute->getValue<const Char*>();
		if (Strcmp(type->getValue<const Char*>(), SXT("string")) == 0)
		{
			writingFunction += SXT("\"");
		}
	}
	else
	{
		writingFunction += getTypeDefaultValue(type->getValue<const Char*>());
	}

	writingFunction += inAttribute ? SXT(")\r\n	{\r\n		attribute = node->addAttribute(")
									: SXT(")\r\n	{\r\n		childNode = node->addChild(");
	writingFunction += LEFT_QUOTE;
	writingFunction += child->getName();
	writingFunction += inAttribute ? SXT("\");\r\n		attribute->set")
									: SXT("\");\r\n		childNode->set");
	typeName = type->getValue<const Char*>();
	typeName[0] -= 32;
	writingFunction += typeName;
	writingFunction += SXT("(");
	writingFunction += child->getName();
	writingFunction += SXT(");\r\n	}\r\n");
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void XmlSchema::addSimpleVector(const XmlNode* child, String& structDefinition, size_t typeWidth,
								 String& readingFunction, String& writingFunction) const
{
	assert(child != NULL);
	XmlAttribute* type = child->findAttribute(ATTR_TYPE);
	if (type == NULL)
	{
		return;
	}
	
	String typeString = SXT("std::vector<");
	typeString += getSimpleTypeString(type);
	typeString += SXT(">");

	size_t thisWidth = typeString.size();
	assert(thisWidth < typeWidth + 1);
	for (size_t i = 0; i < typeWidth + 1 - thisWidth; ++i)
	{
		typeString += SXT(" ");
	}
	structDefinition += SXT("	");
	structDefinition += typeString;
	structDefinition += getPluralName(child->getName());
	structDefinition += SXT(";\r\n");	

	readingFunction += SXT("\r\n	childNode = node->findFirstChild(");
	readingFunction += LEFT_QUOTE;
	readingFunction += child->getName();
	readingFunction += SXT("\", iter);\r\n	while (childNode != NULL)\r\n	{\r\n		");
	readingFunction += getPluralName(child->getName());
	readingFunction += SXT(".resize(");
	readingFunction += getPluralName(child->getName());
	readingFunction += SXT(".size() + 1);\r\n		");
	readingFunction += getPluralName(child->getName());
	readingFunction += SXT(".back() = childNode->get");
	String typeName = type->getValue<const Char*>();
	typeName[0] -= 32;
	readingFunction += typeName;
	readingFunction += SXT("();\r\n		childNode = node->findNextChild(");
	readingFunction += LEFT_QUOTE;
	readingFunction += child->getName();
	readingFunction += SXT("\", iter);\r\n	}\r\n");

	writingFunction += SXT("\r\n	for (std::vector<");
	writingFunction += getSimpleTypeString(type);
	writingFunction += SXT(">::const_iterator iter = ");
	writingFunction += getPluralName(child->getName());
	writingFunction += SXT(".begin();\r\n		  iter != ");
	writingFunction += getPluralName(child->getName());
	writingFunction += SXT(".end();\r\n		  ++iter)\r\n	{\r\n		const ");
	writingFunction += getSimpleTypeString(type);
	writingFunction += SXT("& value = *iter;\r\n");
	writingFunction += SXT("		childNode = node->addChild(");
	writingFunction += LEFT_QUOTE;
	writingFunction += child->getName();
	writingFunction += SXT("\");\r\n		childNode->set");
	writingFunction += typeName;
	writingFunction += SXT("(value);\r\n	}\r\n");
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void XmlSchema::addStructMember(const XmlNode* child, String& structDefinition, size_t typeWidth,
								 String& readingFunction, String& writingFunction) const
{
	assert(child != NULL);
	bool recursive = (child->findAttribute(ATTR_RECURSIVE) != NULL);

	structDefinition += SXT("	");
	structDefinition += child->getName();
	size_t thisWidth = Strlen(child->getName());
	assert(thisWidth < typeWidth + 1);
	for (size_t i = 0;	i < typeWidth + 1 - thisWidth; ++i)
	{
		structDefinition += SXT(" ");
	}
	structDefinition += recursive ? SXT("*Child") : child->getName();
	structDefinition += SXT(";\r\n");

	readingFunction += SXT("\r\n	childNode = node->findChild(");
	readingFunction += LEFT_QUOTE;
	readingFunction += child->getName();
	readingFunction += SXT("\");\r\n	if (childNode != NULL)\r\n	{\r\n		");
	if (recursive)
	{
		readingFunction += SXT("Child = new ");
		readingFunction += child->getName();
		readingFunction += SXT(";\r\n		Child->read(childNode);\r\n	}\r\n");
	}
	else
	{
		readingFunction += child->getName();
		readingFunction += SXT(".read(childNode);\r\n	}\r\n");
	}
	if (recursive)
	{
		writingFunction += SXT("	if (Child != NULL)\r\n	{\r\n		childNode = node->addChild(");
		writingFunction += LEFT_QUOTE;
		writingFunction += child->getName();
		writingFunction += SXT("\");\r\n		Child->write(childNode);\r\n	}\r\n");
	}
	else
	{
		writingFunction += SXT("\r\n	childNode = node->addChild(");
		writingFunction += LEFT_QUOTE;
		writingFunction += child->getName();
		writingFunction += SXT("\");\r\n	");
		writingFunction += child->getName();
		writingFunction += SXT(".write(childNode);\r\n");
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void XmlSchema::addStructVector(const XmlNode* child, String& structDefinition, size_t typeWidth,
								 String& readingFunction, String& writingFunction) const
{
	assert(child != NULL);

	structDefinition += SXT("	std::vector<");
	structDefinition += child->getName();
	structDefinition += SXT(">");
	size_t thisWidth = Strlen(child->getName()) + Strlen(SXT("std::vector<>"));
	assert(thisWidth < typeWidth + 1);
	for (size_t i = 0;	i < typeWidth + 1 - thisWidth; ++i)
	{
		structDefinition += SXT(" ");
	}
	structDefinition += getPluralName(child->getName());
	structDefinition += SXT(";\r\n");

	readingFunction += SXT("\r\n	childNode = node->findFirstChild(");
	readingFunction += LEFT_QUOTE;
	readingFunction += child->getName();
	readingFunction += SXT("\", iter);\r\n	while (childNode != NULL)\r\n	{\r\n		");
	readingFunction += getPluralName(child->getName());
	readingFunction += SXT(".resize(");
	readingFunction += getPluralName(child->getName());
	readingFunction += SXT(".size() + 1);\r\n		");
	readingFunction += getPluralName(child->getName());
	readingFunction += SXT(".back().read(childNode);\r\n		childNode = node->findNextChild(");
	readingFunction += LEFT_QUOTE;
	readingFunction += child->getName();
	readingFunction += SXT("\", iter);\r\n	}\r\n");

	writingFunction += SXT("\r\n	for (std::vector<");
	writingFunction += child->getName();
	writingFunction += SXT(">::const_iterator iter = ");
	writingFunction += getPluralName(child->getName());
	writingFunction += SXT(".begin();\r\n		  iter != ");
	writingFunction += getPluralName(child->getName());
	writingFunction += SXT(".end();\r\n		  ++iter)\r\n	{\r\n		const ");
	writingFunction += child->getName();
	writingFunction += SXT("& obj = *iter;\r\n");
	writingFunction += SXT("		childNode = node->addChild(");
	writingFunction += LEFT_QUOTE;
	writingFunction += child->getName();
	writingFunction += SXT("\");\r\n		obj.write(childNode);\r\n	}\r\n");
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void XmlSchema::addConstructorItem(const XmlNode* child, String& structDefinition, int& index) const
{
	XmlAttribute* type = child->findAttribute(ATTR_TYPE);
	bool recursive = (child->findAttribute(ATTR_RECURSIVE) != NULL);
	if (type == NULL && !recursive)
	{
		return;
	}
	XmlAttribute* multiple = child->findAttribute(ATTR_MULTIPLE);
	if (multiple != NULL && multiple->getValue<bool>())
	{
		//don't need to construct a vector member
		return;
	}
	XmlAttribute* defaultAttribute = child->findAttribute(ATTR_DEFAULT);
	if (type != NULL
		&& Strcmp(type->getValue<const Char*>(), SXT("string")) == 0
		&& defaultAttribute == NULL)
	{
		//for String, need construction only when default value exist
		return;
	}

	if (index == 0)
	{
		structDefinition += SXT("	");
		structDefinition += child->getParent()->getName();
		structDefinition += SXT("()\r\n		:	");
	}
	else
	{
		structDefinition += SXT("		,	");
	}
	if (recursive)
	{
		structDefinition += SXT("Child");
	}
	else
	{
		structDefinition += child->getName();
	}
	structDefinition += SXT("(");
	++index;

	if (defaultAttribute != NULL)
	{
		if (Strcmp(type->getValue<const Char*>(), SXT("string")) == 0)
		{
			structDefinition += LEFT_QUOTE;
			structDefinition += defaultAttribute->getValue<const Char*>();
			structDefinition += SXT("\"");
		}
		else
		{
			structDefinition += defaultAttribute->getValue<const Char*>();
		}
	}
	else
	{
		if (recursive)
		{
			structDefinition += SXT("NULL");
		}
		else
		{
			structDefinition += getTypeDefaultValue(type->getValue<const Char*>());
		}
	}
	structDefinition += SXT(")\r\n");
}

///////////////////////////////////////////////////////////////////////////////////////////////////
String XmlSchema::getSimpleTypeString(const XmlAttribute* type) const
{
	String typeString;
	if (Strcmp(type->getValue<const Char*>(), SXT("string")) == 0)
	{
	#ifdef SLIM_USE_WCHAR
		typeString = L"std::wstring";
	#else
		typeString = "std::string";
	#endif
	}
	else
	{
		typeString = type->getValue<const Char*>();
	}
	return typeString;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
const Char* XmlSchema::getTypeDefaultValue(const Char* type) const
{
	if (Strcmp(type, SXT("string")) == 0)
	{
		return LEFT_QUOTE SXT("\"");
	}
	if (Strcmp(type, SXT("bool")) == 0)
	{
		return SXT("false");
	}
	if (Strcmp(type, SXT("int")) == 0)
	{
		return SXT("0");
	}
	if (Strcmp(type, SXT("float")) == 0)
	{
		return SXT("0.0f");
	}
	return SXT("deadbeef");
}

///////////////////////////////////////////////////////////////////////////////////////////////////
String XmlSchema::getPluralName(const String& name) const
{
	if (name.size() <= 0)
	{
		return SXT("");
	}
	String plural = name;
	if (name[name.size()-1] == SXT('o')
		|| name[name.size()-1] == SXT('s')
		|| name[name.size()-1] == SXT('x'))
	{
		plural += SXT("es");
	}
	else if (name[name.size() - 1] == SXT('y')
		&& (name.size() > 2 && name[name.size()-2] != SXT('a')
							 && name[name.size()-2] != SXT('e')
							 && name[name.size()-2] != SXT('i')
							 && name[name.size()-2] != SXT('o')
							 && name[name.size()-2] != SXT('u')))
	{
		plural[name.size() - 1] = SXT('i');
		plural += SXT("es");
	}
	else if (name.size() > 2 && name[name.size()-1] == SXT('h')
		&& (name[name.size()-2] == SXT('s') || name[name.size()-2] == SXT('c')))
	{
		plural += SXT("es");
	}
	else
	{
		plural += SXT("s");
	}
	//sorry, I don't want to be writing this for a whole day, so please don't name your data as sheep, child, deer, knife...
	return plural;
}

}
